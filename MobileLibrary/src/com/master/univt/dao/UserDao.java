package com.master.univt.dao;

import java.util.List;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteStatement;
import android.util.Log;

import de.greenrobot.dao.AbstractDao;
import de.greenrobot.dao.Property;
import de.greenrobot.dao.internal.DaoConfig;
import de.greenrobot.dao.query.Query;
import de.greenrobot.dao.query.QueryBuilder;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT.
/**
 * DAO for table USER.
 */
public class UserDao extends AbstractDao<User, Long>
{

  public static final String TABLENAME = "USER";

  /**
   * Properties of entity User.<br/>
   * Can be used for QueryBuilder and for referencing column names.
   */
  public static class Properties
  {
    public final static Property Id = new Property(0, Long.class, "id", true, "_id");
    public final static Property UId = new Property(1, String.class, "uId", false, "U_ID");
    public final static Property Username = new Property(2, String.class, "username", false, "USERNAME");
    public final static Property Name = new Property(3, String.class, "name", false, "NAME");
    public final static Property HasActiveContent = new Property(4, Boolean.class, "hasActiveContent", false,
      "HAS_ACTIVE_CONTENT");
    public final static Property FreeLecturesCount = new Property(5, Integer.class, "freeLecturesCount", false,
      "FREE_LECTURES_COUNT");
    public final static Property SecurityToken = new Property(6, String.class, "securityToken", false, "SECURITY_TOKEN");
    public final static Property NewRegistration = new Property(7, Boolean.class, "newRegistration", false,
      "NEW_REGISTRATION");
    public final static Property IsLoggedIn = new Property(8, Boolean.class, "isLoggedIn", false, "IS_LOGGED_IN");

    public final static Property DiscoveryAreaEnabled = new Property(9, boolean.class, "discoveryAreaEnabled", false,
      "DISCOVERY_AREA_ENABLED");
  };

  private DaoSession daoSession;

  private Query<User> user_OrganizationsQuery;

  public UserDao(final DaoConfig config)
  {
    super(config);
  }

  public UserDao(final DaoConfig config, final DaoSession daoSession)
  {
    super(config, daoSession);
    this.daoSession = daoSession;
  }

  /** Creates the underlying database table. */
  public static void createTable(final SQLiteDatabase db, final boolean ifNotExists)
  {
    String constraint = ifNotExists ? "IF NOT EXISTS " : "";
    db.execSQL("CREATE TABLE " + constraint + "'USER' (" + //
      "'_id' INTEGER PRIMARY KEY ," + // 0: id
      "'U_ID' TEXT NOT NULL UNIQUE ," + // 1: uId
      "'USERNAME' TEXT," + // 2: username
      "'NAME' TEXT," + // 3: name
      "'HAS_ACTIVE_CONTENT' INTEGER," + // 4: hasActiveContent
      "'FREE_LECTURES_COUNT' INTEGER," + // 5: freeLecturesCount
      "'SECURITY_TOKEN' TEXT," + // 6: securityToken
      "'NEW_REGISTRATION' INTEGER," + // 7: newRegistration
      "'IS_LOGGED_IN' INTEGER);"); // 8: isLoggedIn
    updateTable(db);
  }

  public static void updateTable(final SQLiteDatabase db)
  {
    try
    {
      db.execSQL("ALTER TABLE 'USER' ADD COLUMN 'DISCOVERY_AREA_ENABLED' INTEGER NOT NULL DEFAULT 1;");
    }
    catch (SQLiteException ex)
    {
    }
  }

  /** Drops the underlying database table. */
  public static void dropTable(final SQLiteDatabase db, final boolean ifExists)
  {
    String sql = "DROP TABLE " + (ifExists ? "IF EXISTS " : "") + "'USER'";
    db.execSQL(sql);
  }

  /** @inheritdoc */
  @Override
  protected void bindValues(final SQLiteStatement stmt, final User entity)
  {
    stmt.clearBindings();

    Long id = entity.getId();
    if (id != null)
    {
      stmt.bindLong(1, id);
    }
    stmt.bindString(2, entity.getUId());

    String username = entity.getUsername();
    if (username != null)
    {
      stmt.bindString(3, username);
    }

    String name = entity.getName();
    if (name != null)
    {
      stmt.bindString(4, name);
    }
  }

  @Override
  protected void attachEntity(final User entity)
  {
    super.attachEntity(entity);
    entity.__setDaoSession(daoSession);
  }

  /** @inheritdoc */
  @Override
  public Long readKey(final Cursor cursor, final int offset)
  {
    return cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0);
  }

  /** @inheritdoc */
  @Override
  public User readEntity(final Cursor cursor, final int offset)
  {
    User entity = new User( //
      cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id
      cursor.getString(offset + 1), // uId
      cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2), // username
      cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3) // name
      );
    return entity;
  }

  /** @inheritdoc */
  @Override
  public void readEntity(final Cursor cursor, final User entity, final int offset)
  {
    entity.setId(cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0));
    entity.setUId(cursor.getString(offset + 1));
    entity.setUsername(cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2));
    entity.setName(cursor.isNull(offset + 3) ? null : cursor.getString(offset + 3));
  }

  /** @inheritdoc */
  @Override
  protected Long updateKeyAfterInsert(final User entity, final long rowId)
  {
    Log.d("LOG", "Update key after insert:" + rowId);
    entity.setId(rowId);
    return rowId;
  }

  /** @inheritdoc */
  @Override
  public Long getKey(final User entity)
  {
    if (entity != null)
    {
      return entity.getId();
    }
    else
    {
      return null;
    }
  }

  /** @inheritdoc */
  @Override
  protected boolean isEntityUpdateable()
  {
    return true;
  }

  /** Internal query to resolve the "organizations" to-many relationship of User. */
  public List<User> _queryUser_Organizations(Long id)
  {
    synchronized (this)
    {
      if (user_OrganizationsQuery == null)
      {
        QueryBuilder<User> queryBuilder = queryBuilder();
        queryBuilder.where(Properties.Id.eq(null));
        user_OrganizationsQuery = queryBuilder.build();
      }
    }
    Query<User> query = user_OrganizationsQuery.forCurrentThread();
    query.setParameter(0, id);
    return query.list();
  }
}
